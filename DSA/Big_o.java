public class Big_o {
    public static void main(String [] args){
        // Big O notation
        /*
         * it is code slows as data grows
         * Describe the performance of an algorithm as the amount of data increases!
         * Machine independent(number of steps to completion )
         * Ignore small operations O(n + 1) -> O(n)
         * Examples: O(1), O(n), O(log n), O(n^2)
         * n = amount of data
         * 
         * 
         //O(n) linear time
         //if n = 1000, then 1000 steps
         int addUp(int n){
            int sum = 0;
            for(int i = 0; i <= n; i++){
                sum += 1;
            }
            return sum;
         }
        

         // O(1) constant time
         //n = 10000, only 2 steps
         int addUp(int n){
            int sum = n * (n + 1)/2;
            return sum;
         }

         // based of their efficiency

        1. O(1) = constant time
                ex. random access of an element in an array
                inserting at the beginning of a linked list

        2. O(log n) = logarithmic time
                ex. binary search

        3. O(n) = linear time
             ex. looping through items in an array
             searching through a linked list

        4. O(n log n) = quasilinear time
                ex. quicksort
                mergesort
                heapsort
            
        5. O(n^2) = quadratic time
                ex. insertion sort
                selection sort
                bubble sort
        6. O(n!) = factorial time
            ex. travelling salesman problem
        




         */


    }
}
